import{F as FP}from"./index-f7e0320c.js";import{M as Maths}from"./index-cac59f77.js";import{S as Strings}from"./index-19d14380.js";const COLORS={BLUE:34,CYAN:36,GRAY:90,GREEN:32,MAGENTA:35,RED:31,WHITE:37,YELLOW:33};const getColor=(msg,code)=>`[${code}m${msg}[39m`;const colors={blue:msg=>getColor(msg,COLORS.BLUE),bold:msg=>`[0;1m${msg}[0;0m`,cyan:msg=>getColor(msg,COLORS.CYAN),gray:msg=>getColor(msg,COLORS.GRAY),green:msg=>getColor(msg,COLORS.GREEN),grey:msg=>getColor(msg,COLORS.GRAY),magenta:msg=>getColor(msg,COLORS.MAGENTA),red:msg=>getColor(msg,COLORS.RED),white:msg=>getColor(msg,COLORS.WHITE),yellow:msg=>getColor(msg,COLORS.YELLOW)};const WS=" ";const EOL="\n";function trace(msg,method="stdout"){const useTTY=Boolean(process[method]&&process[method].isTTY);if(useTTY)process[method].write(`${msg}${EOL}`);else console.log(msg)}function buildMessageToTrace(msg,color=false,prefix=false,type=false){const entries=[prefix,type,msg];const prefixedMessage=entries.filter(v=>v).join(WS);if(!color)return prefixedMessage;return colors[color](prefixedMessage)}const Logger={cloneNS:ns=>{const clone=Object.keys(Logger).reduce((acc,key)=>{return{...acc,[key]:msg=>Logger[key](msg,ns)}},{});return{...clone}},colors:colors,debug:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"gray",prefix);trace(message)},error:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"red",prefix,"Error:");trace(message,"stderr")},info:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"magenta",prefix);trace(message)},log:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"white",prefix);trace(message)},ok:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"green",prefix);trace(message)},warning:(msg,prefix=false)=>{const message=buildMessageToTrace(msg,"yellow",prefix,"Warning:");trace(message)}};var Core=Object.freeze({__proto__:null,Colors:colors,Logger:Logger});const FUNC_NAME_REGEX=/function (.{1,})\(/;function getProtoName(instance){let{name:name}=instance.constructor;if(name)return name;const results=FUNC_NAME_REGEX.exec(this.constructor.toString());name=results&&results.length>1?results[1]:"";return name}const merge=(obj1,obj2)=>{return{...obj1,...obj2}};const isEmpty=obj=>{const keys=Object.keys(obj);return keys.length>0};var Objects=Object.freeze({__proto__:null,getProtoName:getProtoName,merge:merge,isEmpty:isEmpty});const isEmpty$1=val=>{const isBoolean=typeof val==="boolean";const isFunction=typeof val==="function";if(isFunction||isBoolean)return false;if(!val)return true;if(typeof val==="string"&&val.trim()==="")return true;if(Array.isArray(val)&&val.length<=0)return true;return false};const sleep=ms=>new Promise(resolve=>setTimeout(resolve,ms));function debounce(func,wait=250,immediate=false){let timeout;return function __debounce__(...args){clearTimeout(timeout);timeout=setTimeout(()=>{timeout=null;if(!immediate)func.apply(this,args)},wait);if(immediate&&!timeout)func.apply(this,[...args])}}const parseArray=vals=>vals.reduce((acc,val)=>({...acc,[val]:val}),{});const parseObject=vals=>Object.keys(vals).reduce((acc,val)=>({...acc,[val]:val}),{});const mirrorKeys=(keys,parsers=[])=>{const isarray=Array.isArray(keys);const isobject=keys&&typeof keys==="object";const isvalid=isarray||isobject;if(!isvalid)return keys;const modifiers=parsers.filter(fn=>typeof fn==="function");const parser=isarray?parseArray:parseObject;let result=parser(keys);if(!modifiers||!modifiers.length)return result;result=Object.keys(result).reduce((acc,key)=>{const modifiedValue=modifiers.reduce((prevacc,fn)=>prevacc&&fn(prevacc)||fn(key),undefined);return{...acc,[key]:modifiedValue}},{});return result};const toggleBooleans=(boolVal,shouldToggle=false)=>{if(!shouldToggle)return boolVal;const result=!!(shouldToggle^boolVal);return result};var Utils=Object.freeze({__proto__:null,isEmpty:isEmpty$1,sleep:sleep,debounce:debounce,mirrorKeys:mirrorKeys,toggleBooleans:toggleBooleans});var index={Core:Core,FP:FP,Maths:Maths,Objects:Objects,Strings:Strings,Utils:Utils};export default index;
